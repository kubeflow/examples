const util = require('util');
const snippets = require('../snippets');

module.exports = function(RED) {
    function Algorithm(config) {
        RED.nodes.createNode(this, config);
        var node = this;

        // Function for RandomForest algorithm
        function randomForest(msg) {
            const script = util.format(snippets.RANDOMFOREST, config.n_estimators, config.criterion, config.max_depth, config.min_samples_split, config.min_samples_leaf);
            msg.payload += script;
            return msg;
        }

        // Function for DecisionTree algorithm
        function decisionTree(msg) {
            const script = util.format(snippets.DECISIONTREE, config.criterion, config.splitter, config.max_depth, config.min_samples_split, config.min_samples_leaf);
            msg.payload += script;
            return msg;
        }

        // Function for LogisticRegression algorithm
        function logisticRegression(msg) {
            const script = util.format(snippets.LOGISTICREGRESSION, config.penalty, config.solver);
            msg.payload += script;
            return msg;
        }

        function neuralNetwork(msg) {
            var script = '';
            for(var k in config.userInputs){
                switch (config.userInputs[k].type) {
                    case "Conv2D":
                        var template1 = 'tf.keras.layers.Conv2D(%s,(%s,%s),padding="%s",activation="%s",input_shape=(%s,%s,%s)),';
                        var template2 = 'tf.keras.layers.Conv2D(%s,(%s,%s),padding="%s",activation="%s"),';
                        if (config.userInputs[k].datainput.length<6){
                            for (let i = 0; i < 3; i++) {
                                template2 = template2.replace('%s', config.userInputs[k].datainput[i]);
                            }
                            for (let i = 0; i < config.userInputs[k].dataselect.length; i++) {
                                template2 = template2.replace('%s', config.userInputs[k].dataselect[i]);
                            }
                            script+=template2;
                        }else{
                            for (let i = 0; i < 3; i++) {
                                template1 = template1.replace('%s', config.userInputs[k].datainput[i]);
                            }
                            for (let i = 0; i < config.userInputs[k].dataselect.length; i++) {
                                template1 = template1.replace('%s', config.userInputs[k].dataselect[i]);
                            }
                            for (let i = 3; i < config.userInputs[k].datainput.length; i++) {
                                template1 = template1.replace('%s', config.userInputs[k].datainput[i])
                            }
                            script+=template1;
                        }
                        break;            
                    case "MaxPooling2D":
                        var template = "tf.keras.layers.MaxPooling2D((%s,%s)),";
                        for (let i in config.userInputs[k].datainput){
                            template = template.replace('%s', config.userInputs[k].datainput[i])
                        }
                        script+=template;
                        break;
                    case "Flatten":
                        var template1 = "tf.keras.layers.Flatten(input_shape=(%s,%s,%s)),";
                        var template2 = "tf.keras.layers.Flatten(),";
                        if (config.userInputs[k].datainput.length){
                            for (let i in config.userInputs[k].datainput){
                                template1 = template1.replace('%s', config.userInputs[k].datainput[i])
                            }
                            script+=template1
                        }else{
                            script+=template2
                        }
                        break;
                    case "Dense":
                        var template = "tf.keras.layers.Dense(%s,activation='%s'),"
                        template = template.replace('%s', config.userInputs[k].datainput[0]);
                        template = template.replace('%s', config.userInputs[k].dataselect[0]);
                        script+=template;
                        break;
                    default:
                        var template = "tf.keras.layers.Dropout(%s),"
                        template = template.replace('%s', config.userInputs[k].datainput[0]);
                        script+=template;
                }

            }
            script = util.format(snippets.NEURALNETWORK, script)           
            msg.payload += script;
            return msg;
        }

        node.on('input', function(msg) {
            switch (config.algorithm) {
                case "randomforest":
                    msg = randomForest(msg);
                    break;
                case "decisiontree":
                    msg = decisionTree(msg);
                    break;
                case "neuralnetwork":
                    msg = neuralNetwork(msg);
                    break;
                default:
                    msg = logisticRegression(msg);

            }
            
            msg.algorithm = config.algorithm;
            node.send(msg);
        });
    }

    RED.nodes.registerType("algorithm", Algorithm);
}
