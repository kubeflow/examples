const fs = require('fs');
const util = require('util');
const snippets = require('../snippets');
const spawn = require('child_process').spawn;

class PythonshellNode {
    constructor(config) {
        this.spawn = spawn;
        this.onStatus = ()=>{};
    }
    onInput(msg, node, out, err) {
        this.pyfile = msg.path;
        var spawnCmd = "python3";
        this.py = this.spawn(spawnCmd, ['-u', this.pyfile], {
            cwd: this.pyfile.substring(0, this.pyfile.lastIndexOf('/'))
        });
        this.onStatus({fill:"green",shape:"dot",text:"Standby"});

        var py = this.py;
        var dataString = '';
        var errString = '';

        py.stdout.on('data', data => {
            clearTimeout(this.standbyTimer)
            this.onStatus({fill:"green",shape:"dot",text:"Processing data"});
            let dataStr = data.toString();
            let lines = dataStr.split('\n');
            for (let line of lines) {
                if (line.startsWith("mypvc-name:")) {
                    msg.pvc_names = line.split("mypvc-name:")[1].trim();
                }else if (line.trim() !== "") {
                    dataString += line + "\n";
                }
            }
            if (dataString != ""){
                node.warn(dataString.trim());
            }
            dataString = '';
            this.standbyTimer = setTimeout(()=>{
                this.onStatus({fill:"green",shape:"dot",text:"Standby"})
              }, 2000)
        });

        py.stderr.on('data', data => {
            errString += String(data);
            this.onStatus({fill:"red",shape:"dot",text:"Error: " + errString});
        });
        py.stderr.on('error', console.log)
        py.stdout.on('error', console.log)
        py.stdin.on('error', console.log)
        py.on('error', console.log)

        py.on('close', code => {
            if (code) {
                err('exit code: ' + code + ', ' + errString);
                this.onStatus({fill:"red",shape:"dot",text:"Exited: " + code})
            } else {
                out(msg);
                this.onStatus({fill:"green",shape:"dot",text:"Done"})
            } 
            this.py = null;
            setTimeout(()=>{
                this.onStatus({})
              }, 2000)
        });
    };

    onClose() {
        if (this.py) {
            this.py.kill();
            this.py = null;
        }
    }

    setStatusCallback(callback) {
        this.onStatus = callback;
    }
}

module.exports = function(RED) {
    function ModelCreator(config) {
        RED.nodes.createNode(this,config);
        var node = this;
        var model_name = config.model_name;
        var script = '';
        var epochs = config.epochs;
        var overwrite = config.overwrite;
        var pyNode = new PythonshellNode(config);
        pyNode.setStatusCallback(node.status.bind(node));
        var hasBeenCalled = false;

        node.on('input', function(msg) {
            if (hasBeenCalled) {
                return;
            }
            hasBeenCalled = true;

            if (msg.algorithm === "randomforest"){
                script = util.format(snippets.UPLOAD_RANDOMFOREST, epochs, model_name, model_name);
            }else if (msg.algorithm === "decisiontree"){
                script = util.format(snippets.UPLOAD_DECISIONTREE, epochs, model_name, model_name);
            }else if (msg.algorithm === "neuralnetwork"){
                script = util.format(snippets.UPLOAD_NEURALNETWORK, epochs, model_name, config.validation_split, config.optimizer, config.loss, model_name);
            }else{
                script = util.format(snippets.UPLOAD_LOGISTICREGRESSION, epochs, model_name, model_name);
            }
            
            msg.payload += script;
            var path = `/data/1.connect-kubeflow/py/${model_name}.py`
            if (overwrite) {
                 fs.writeFile(path, msg.payload, function (err) {
                    if (err) {
                        node.error('Failed to write to file: ' + err.message);
                        return;
                    }
                });
            } else {
                fs.appendFile(path, msg.payload, function (err) {
                    if (err) {
                        node.error('Failed to write to file: ' + err.message);
                        return;
                    }
                });
            }
            msg.path = path
            pyNode.onInput(msg, node, function(result) {
                msg.pvc_names = result.pvc_names; 
                msg.modelname = model_name;
                node.send(msg);
            }, function(error) {
                node.error(error);
            }); 
            
        });
        node.on('close', ()=>pyNode.onClose());
    }
    RED.nodes.registerType("model", ModelCreator);

    RED.httpAdmin.post("/model/:id", RED.auth.needsPermission('model.read'), function(req, res) {
        var filePath = req.body.filePath;
        if(fs.existsSync(filePath)) {
            res.json({fileExists: true});
        } else {
            res.json({fileExists: false});
        }
     
    });
    
}






