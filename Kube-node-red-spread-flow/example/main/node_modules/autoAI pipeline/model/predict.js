"use strict";
const fs = require('fs');
const util = require('util');
const snippets = require('../snippets');
const spawn = require('child_process').spawn;

class PythonshellNode {
    constructor(config) {
        this.spawn = spawn;
        this.onStatus = ()=>{};
    }
    async onInput (msg, node, out, err) {
        if (msg.path && msg.path.length === 0) {
            // All paths have been executed, pass the message to the next node
            out(msg);
            return;
        }
        
        this.pyfile = msg.path[0];
        var spawnCmd = "python3";
        this.py = this.spawn(spawnCmd, ['-u', this.pyfile], {
            cwd: this.pyfile.substring(0, this.pyfile.lastIndexOf('/'))
        });
        this.onStatus({fill:"green",shape:"dot",text:"Standby"});

        var py = this.py;
        var dataString = '';
        var errString = '';

        py.stdout.on('data', data => {
            clearTimeout(this.standbyTimer)
            this.onStatus({fill:"green",shape:"dot",text:"Processing data"});
            let dataStr = data.toString();
            let lines = dataStr.split('\n');
            for (let line of lines) {
                dataString += line + "\n";
            }
            if (dataString.trim() != ""){
                node.warn(dataString.trim());
            }
            dataString = '';
            this.standbyTimer = setTimeout(()=>{
                this.onStatus({fill:"green",shape:"dot",text:"Standby"})
              }, 2000)
        });

        py.stderr.on('data', data => {
            errString += String(data);
            this.onStatus({fill:"red",shape:"dot",text:"Error: " + errString});
        });
        py.stderr.on('error', console.log)
        py.stdout.on('error', console.log)
        py.stdin.on('error', console.log)
        py.on('error', console.log)

        py.on('close', async code => {
            if (code) {
                err('exit code: ' + code + ', ' + errString);
                this.onStatus({fill:"red",shape:"dot",text:"Exited: " + code})
            } else {
                out(msg);
                this.onStatus({fill:"green",shape:"dot",text:"Done"})
            } 
            this.py = null;
            setTimeout(()=>{
                this.onStatus({})
            }, 2000);
            msg.path = msg.path.slice(1); 
            await this.onInput(msg, node, out, err);  
        });
    };

    onClose() {
        if (this.py) {
            this.py.kill();
            this.py = null;
        }
    }

    setStatusCallback(callback) {
        this.onStatus = callback;
    }
}
module.exports = function(RED) {
    function ModelPredict(config) {
        RED.nodes.createNode(this,config);
        var node = this;          
        var pyNode = new PythonshellNode(config);
        pyNode.setStatusCallback(node.status.bind(node));
        var hasBeenCalled = false;
        
        node.on('input', function(msg) {
            
            if (msg.modelname != config.model || hasBeenCalled ) {
                return;
            }
            hasBeenCalled = true;

            const scriptComponents = assembleScript(config, msg);
            let script = util.format(snippets.P_DATA_UPLOAD, scriptComponents.path, scriptComponents.obj_name)
            msg.path = ['/data/1.connect-kubeflow/py/predictdata.py','/data/1.connect-kubeflow/py/prediction.py','/data/1.connect-kubeflow/py/predresult.py'];

            fs.writeFile(msg.path[0], script, function (err) {
                if (err) {
                    node.error('Failed to write to file: ' + err.message);
                    return;
                }
            });

            fs.writeFile(msg.path[1], scriptComponents.script, function (err) {
                if (err) {
                    node.error('Failed to write to file: ' + err.message);
                    return;
                }
            });

            fs.writeFile(msg.path[2], snippets.RETRIEVEPRED, function (err) {
                if (err) {
                    node.error('Failed to write to file: ' + err.message);
                    return;
                }
            });

            pyNode.onInput(msg, node, function(result) {
                if(result.path.length===0){
                    msg.payload = "Finish.";
                    node.send(msg);
                }
            }, function(error) {
                node.error(error);
            }); 
            
        });
        node.on('close', ()=>pyNode.onClose());
        
        function assembleScript(config, msg) {
        const {
            model, path, datatype, height, width, channel
        } = config;
        
        const obj_name = path.substring(path.lastIndexOf('/') + 1, path.length);

        const flag = (channel === "1" )
            ? "IMREAD_GRAYSCALE"
            : "IMREAD_COLOR";

        const scaler = msg.featurescaling
            ? "True"
            : "False";

        const classnames = (msg.source === "traditional")
            ? (msg.dataset === "mnist"
                ? "['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']"
                : "['airplane','automobile','bird','cat','deer','dog','frog','horse','ship','truck']")
            : msg.classnames;

        

            return {
                script: util.format(snippets.MODELPREDICT,process.env.KUBEFLOW_HOST, process.env.KUBEFLOW_USERNAME, process.env.KUBEFLOW_PASSWORD, model, process.env.MINIO_HOST, process.env.MINIO_ROOT_USER, process.env.MINIO_ROOT_PASSWORD, obj_name, datatype, flag, height, width, scaler, msg.fill_na, msg.labelencoding, msg.onehotencoding, msg.datareshape, classnames),
                path,
                obj_name
            };
        }
    }
    RED.nodes.registerType("model predict", ModelPredict);

}