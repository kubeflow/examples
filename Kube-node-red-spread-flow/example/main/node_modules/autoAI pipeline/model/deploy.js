"use strict";
const fs = require('fs');
const util = require('util');
const snippets = require('../snippets');
const spawn = require('child_process').spawn;

class PythonshellNode {
    constructor(config) {
        this.spawn = spawn;
        this.onStatus = ()=>{};
    }
    onInput(msg, node, out, err) {
        this.pyfile = msg.path;
        var spawnCmd = "python3";
        this.py = this.spawn(spawnCmd, ['-u', this.pyfile], {
            cwd: this.pyfile.substring(0, this.pyfile.lastIndexOf('/'))
        });
        this.onStatus({fill:"green",shape:"dot",text:"Standby"});

        var py = this.py;
        var dataString = '';
        var errString = '';

        py.stdout.on('data', data => {
            clearTimeout(this.standbyTimer)
            this.onStatus({fill:"green",shape:"dot",text:"Processing data"});
            let dataStr = data.toString();
            let lines = dataStr.split('\n');
            for (let line of lines) {
                dataString += line + "\n";
            }
            if (dataString.trim() != ""){
                node.warn(dataString.trim());
            }
            dataString = '';
            this.standbyTimer = setTimeout(()=>{
                this.onStatus({fill:"green",shape:"dot",text:"Standby"})
              }, 2000)
        });

        py.stderr.on('data', data => {
            errString += String(data);
            this.onStatus({fill:"red",shape:"dot",text:"Error: " + errString});
        });
        py.stderr.on('error', console.log)
        py.stdout.on('error', console.log)
        py.stdin.on('error', console.log)
        py.on('error', console.log)

        py.on('close', code => {
            if (code) {
                err('exit code: ' + code + ', ' + errString);
                this.onStatus({fill:"red",shape:"dot",text:"Exited: " + code})
            } else {
                out(msg);
                this.onStatus({fill:"green",shape:"dot",text:"Done"})
            } 
            this.py = null;
            setTimeout(()=>{
                this.onStatus({})
              }, 2000)
        });
    };

    onClose() {
        if (this.py) {
            this.py.kill();
            this.py = null;
        }
    }

    setStatusCallback(callback) {
        this.onStatus = callback;
    }
}
module.exports = function(RED) {
      function DeployKserve(config) {
          RED.nodes.createNode(this,config);
          var node = this;
          var script = '';          
          var pyNode = new PythonshellNode(config);
          pyNode.setStatusCallback(node.status.bind(node));

          node.on('input', function(msg) {
              script = msg.algorithm==="neuralnetwork"?util.format(snippets.DEPLOY_TENSORFLOW_KSERVE, msg.pvc_names, msg.modelname, msg.modelname):util.format(snippets.DEPLOY_SKLEARN_KSERVE, msg.pvc_names, msg.modelname, msg.modelname);
              var path = `/data/1.connect-kubeflow/py/deploykserve.py`;
              fs.writeFile(path, script, function (err) {
                  if (err) {
                      node.error('Failed to write to file: ' + err.message);
                      return;
                  }
              });
              msg.path = path;
              pyNode.onInput(msg, node, function(result) {
                  msg.payload = "Finish.";
                  node.send(msg);
              }, function(error) {
                  node.error(error);
              }); 
              
          });
          node.on('close', ()=>pyNode.onClose());
      }
      RED.nodes.registerType("deploy", DeployKserve);
}