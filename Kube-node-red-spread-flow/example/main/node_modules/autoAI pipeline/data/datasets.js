const util = require('util');
const snippets = require('../snippets');
const fs = require("fs");
const spawn = require('child_process').spawn;

class PythonshellNode {
    constructor(config) {
        this.spawn = spawn;
        this.onStatus = ()=>{};
    }
    onInput(msg, node, out, err) {
        this.pyfile = msg.path;
        var spawnCmd = "python3";
        this.py = this.spawn(spawnCmd, ['-u', this.pyfile], {
            cwd: this.pyfile.substring(0, this.pyfile.lastIndexOf('/'))
        });
        this.onStatus({fill:"green",shape:"dot",text:"Standby"});

        var py = this.py;
        var dataString = '';
        var errString = '';

        py.stdout.on('data', data => {
            clearTimeout(this.standbyTimer)
            this.onStatus({fill:"green",shape:"dot",text:"Processing data"});
            let dataStr = data.toString();
            let lines = dataStr.split('\n');
            for (let line of lines) {
                if (line.startsWith("COLUMN_NAMES:")) {
                    msg.col_names = line.split("COLUMN_NAMES:")[1].trim();
                }else if (line.startsWith("Classnames:")){
                    msg.classnames = line.split("Classnames:")[1].trim();
                }else if (line.trim() !== "") {
                    dataString += line + "\n";
                }
            }
            if (dataString != ""){
                node.warn(dataString.trim());
            }
            dataString = '';
            this.standbyTimer = setTimeout(()=>{
                this.onStatus({fill:"green",shape:"dot",text:"Standby"})
              }, 2000)
        });

        py.stderr.on('data', data => {
            errString += String(data);
            this.onStatus({fill:"red",shape:"dot",text:"Error: " + errString});
        });
        py.stderr.on('error', console.log)
        py.stdout.on('error', console.log)
        py.stdin.on('error', console.log)
        py.on('error', console.log)

        py.on('close', code => {
            if (code) {
                err('exit code: ' + code + ', ' + errString);
                this.onStatus({fill:"red",shape:"dot",text:"Exited: " + code})
            } else {
                out(msg);
                this.onStatus({fill:"green",shape:"dot",text:"Done"})
            } 
            this.py = null;
            setTimeout(()=>{
                this.onStatus({})
              }, 2000)
        });
    };

    onClose() {
        if (this.py) {
            this.py.kill();
            this.py = null;
        }
    }

    setStatusCallback(callback) {
        this.onStatus = callback;
    }
}

module.exports = function(RED) {
    function Datasetsopt(config) {
        RED.nodes.createNode(this,config);
        var node = this;
        var customized_datasets = config.customized_datasets;
        var traditional_datasets = config.traditional_datasets;
        var source = config.source;
        var label = config.label_column_name
        var pyNode = new PythonshellNode(config);
        pyNode.setStatusCallback(node.status.bind(node));
        var script = '';
        node.on('input', function(msg) {
            if (source === "traditional") {
                msg.dataset = traditional_datasets;
                msg.source = source;
                script += snippets.IMPORTS;
                script += util.format(snippets.DATASETS, traditional_datasets);
                msg.payload = script; 
                node.send(msg);
            }else{
                msg.path= "/data/1.connect-kubeflow/py/minioupload.py"

                if (!/^['"].*['"]$/.test(label)) {
                    label = `"${label}"`;
                } 

                let obj_name = customized_datasets.substring(customized_datasets.lastIndexOf('/') + 1, customized_datasets.length);
                script = util.format(snippets.DATA_UPLOAD, customized_datasets, obj_name, label)
                fs.writeFile(msg.path, script, function (err) {
                    if (err) {
                        node.error('Failed to write to file: ' + err.message);
                        return;
                    }
                });
               
                pyNode.onInput(msg, node, function(result) {
                    msg.col_names = result.col_names;
                    msg.classnames = result.classnames;
                    msg.label = label;
                    msg.source = source;
                    script = '';
                    script += snippets.IMPORTS;
                    script += util.format(snippets.DATASETS_CUSTOMIZED, process.env.MINIO_HOST, process.env.MINIO_ROOT_USER, process.env.MINIO_ROOT_PASSWORD, obj_name, label)
                    msg.payload = script; 
                    node.send(msg);
                }, function(error) {
                    node.error(error);
                }); 
        
                
            }
        });
        node.on('close', ()=>pyNode.onClose());
    }
    RED.nodes.registerType("datasets", Datasetsopt);

    RED.httpAdmin.get("/datasets/:id", RED.auth.needsPermission('datasets.read'), function(req, res) {
        let path = req.query.path;

        if (fs.existsSync(path)) {
            fs.readFile(path, 'utf8', function(err, data) {
                if (err) {
                    res.status(500).send("Error reading the file.");
                    return;
                }
                
                let columns = parseCSVHeaders(data);
                res.json({ columns: columns });
            });
        } else {
            res.status(500).send("File not found.");
        }
    });
    function parseCSVHeaders(data) {
        return data.split('\n')[0].split(',');
    }
}



