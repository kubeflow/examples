const util = require('util');
const snippets = require('../snippets');
const fs = require("fs");

module.exports = function(RED) {
    function Dataprocedures(config) {
        RED.nodes.createNode(this, config);
        const node = this;

        node.on('input', function(msg) {
            const scriptComponents = assembleScript(config, msg);
            msg.payload += scriptComponents.script;
            msg.fill_na = scriptComponents.p_fillna;
            msg.labelencoding = scriptComponents.p_labelencoding;
            msg.onehotencoding = scriptComponents.p_onehotencoding;
            msg.featurescaling = scriptComponents.feature_scaling_requirement;
            msg.datareshape = scriptComponents.p_datareshape;
            node.send(msg);
        });
    }
    
    function assembleScript(config, msg) {
        const {
            fillna_requirement, fillna, fillnavalue, 
            labelencoding_requirement, labelencoding_column_name, 
            onehotencoding_requirement, onehotencoding_column_name, 
            feature_scaling_requirement, feature_scaling, feature_range_min, feature_range_max,
            data_reshape, height, width, channel
        } = config;
        
        const fill_na = fillna_requirement
            ? (fillna === "fill_na_by_value"
                ? util.format(snippets.FILLNANBYVALUE, msg.label, msg.col_names, fillnavalue)
                : fillna === "fill_na_by_mean"
                ? util.format(snippets.FILLNANBYMEAN, msg.label, msg.col_names)
                : util.format(snippets.FILLNANBYMEDIAN, msg.label, msg.col_names))
            : "";
        
        const p_fillna =  fillna_requirement
            ? (fillna === "fill_na_by_value"
                ? util.format(snippets.P_FILLNANBYVALUE, fillnavalue)
                : fillna === "fill_na_by_mean"
                ? util.format(snippets.P_FILLNANBYMEAN)
                : util.format(snippets.P_FILLNANBYMEDIAN))
            : "";

        const labelencoding = labelencoding_requirement
            ? util.format(snippets.LABELENCODING, msg.label, msg.col_names, labelencoding_column_name)
            : "";

        const p_labelencoding = labelencoding_requirement
            ? util.format(snippets.P_LABELENCODING, labelencoding_column_name)
            : "";

        const onehotencoding = onehotencoding_requirement
            ? util.format(snippets.ONEHOTNCODING, msg.label, msg.col_names, onehotencoding_column_name)
            : "";

        const p_onehotencoding = onehotencoding_requirement
            ? util.format(snippets.P_ONEHOTNCODING, onehotencoding_column_name)
            : ""; 

        const featurescaling = feature_scaling_requirement
            ? (feature_scaling === "normalization"
                ? util.format(snippets.NORMALIZATION, feature_range_min, feature_range_max)
                : util.format(snippets.STANDARDLIZATION))
            : "";

        const datareshape = data_reshape === "1D"
            ? util.format(snippets.DATA_RESHAPE1D)
            : util.format(snippets.DATA_RESHAPE2D, height, width, channel, height, width, channel);
        
        const p_datareshape = data_reshape === "1D"
            ? util.format(snippets.P_DATA_RESHAPE1D)
            : util.format(snippets.P_DATA_RESHAPE2D, height, width, channel);

            return {
                script: util.format(snippets.DATAPROCESS, fill_na, labelencoding, onehotencoding, config.train_test_split, featurescaling, datareshape, process.env.MINIO_HOST, process.env.MINIO_ROOT_USER, process.env.MINIO_ROOT_PASSWORD),
                p_fillna,
                p_labelencoding,
                p_onehotencoding,
                feature_scaling_requirement,
                p_datareshape
            };
        }

    RED.nodes.registerType("data process", Dataprocedures);

    RED.httpAdmin.get("/dataprocess/:id", RED.auth.needsPermission('dataprocess.read'), function(req, res) {
        const path = req.query.path;

        if (fs.existsSync(path)) {
            fs.readFile(path, 'utf8', function(err, data) {
                if (err) {
                    res.status(500).send("Error reading the file.");
                    return;
                }
                
                const columns = parseCSVHeaders(data);
                res.json({ columns: columns });
            });
        } else {
            res.status(500).send("File not found.");
        }
    });
    
    function parseCSVHeaders(data) {
        return data.split('\n')[0].split(',');
    }
}
