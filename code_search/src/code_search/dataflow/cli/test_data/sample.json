{"repo_path":"mrachinskiy/jewelcraft op_cutter/cutter_op.py","content":"# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  JewelCraft jewelry design toolkit for Blender.\n#  Copyright (C) 2015-2018  Mikhail Rachinskiy\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nfrom bpy.types import Operator\nfrom bpy.props import BoolProperty, FloatProperty, IntProperty\n\nfrom .. import var\nfrom ..lib import asset\nfrom .cutter_mesh import create_cutter\nfrom .cutter_draw import Draw\nfrom .cutter_presets import init_presets\n\n\ndef update_coords_handle(self, context):\n    self.girdle_z_top, self.table_z = self.table_z, self.girdle_z_top\n\n\ndef update_coords_hole(self, context):\n    self.hole_z_top, self.culet_z = self.culet_z, self.hole_z_top\n\n\nclass OBJECT_OT_jewelcraft_cutter_add(Draw, Operator):\n    bl_label = \"JewelCraft Make Cutter\"\n    bl_description = \"Create cutter for selected gems\"\n    bl_idname = \"object.jewelcraft_cutter_add\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    auto_presets = BoolProperty(name=\"Use Automated Presets\", description=\"Use automatically generated presets, discards user edits or presets\", default=True)\n\n    detalization = IntProperty(name=\"Detalization\", default=32, min=12, soft_max=64, step=1)\n\n    handle = BoolProperty(name=\"Handle\", default=True, update=update_coords_handle)\n    handle_l_size = FloatProperty(name=\"Handle Length\", step=0.1, unit=\"LENGTH\")\n    handle_w_size = FloatProperty(name=\"Handle Width\", step=0.1, unit=\"LENGTH\")\n    handle_z_top = FloatProperty(name=\"Handle Height Top\", default=0.5, step=0.1, unit=\"LENGTH\")\n    handle_z_btm = FloatProperty(name=\"Handle Height Bottom\", default=0.5, step=0.1, unit=\"LENGTH\")\n\n    girdle_l_ofst = FloatProperty(name=\"Girdle Length Offset\", step=0.1, unit=\"LENGTH\")\n    girdle_w_ofst = FloatProperty(name=\"Girdle Width Offset\", step=0.1, unit=\"LENGTH\")\n    girdle_z_top = FloatProperty(name=\"Girdle Height Top\", default=0.05, step=0.1, unit=\"LENGTH\")\n    girdle_z_btm = FloatProperty(name=\"Girdle Height Bottom\", step=0.1, unit=\"LENGTH\")\n    table_z = FloatProperty(name=\"Table Height\", options={\"HIDDEN\"})\n\n    hole = BoolProperty(name=\"Hole\", default=True, update=update_coords_hole)\n    hole_z_top = FloatProperty(name=\"Hole Height Top/Culet\", default=0.25, step=0.1, unit=\"LENGTH\")\n    hole_z_btm = FloatProperty(name=\"Hole Height Bottom\", default=1.0, step=0.1, unit=\"LENGTH\")\n    hole_l_size = FloatProperty(name=\"Hole Length\", step=0.1, unit=\"LENGTH\")\n    hole_w_size = FloatProperty(name=\"Hole Width\", step=0.1, unit=\"LENGTH\")\n    hole_pos_ofst = FloatProperty(name=\"Hole Position Offset\", step=0.1, unit=\"LENGTH\")\n    culet_z = FloatProperty(name=\"Height Culet\", options={\"HIDDEN\"})\n\n    curve_seat = BoolProperty(name=\"Curve Seat\")\n    curve_seat_segments = IntProperty(name=\"Curve Seat Segments\", default=15, min=2, soft_max=30, step=1)\n    curve_seat_profile = FloatProperty(name=\"Curve Seat Profile\", default=0.5, min=0.15, max=1.0, subtype=\"FACTOR\")\n\n    curve_profile = BoolProperty(name=\"Curve Profile\")\n    curve_profile_segments = IntProperty(name=\"Curve Profile Segments\", default=10, min=1, soft_max=30, step=1)\n    curve_profile_factor = FloatProperty(name=\"Curve Profile Factor\", default=0.1, min=0.0, step=1)\n\n    mul_1 = FloatProperty(name=\"Marquise Profile Factor 1\", default=0.47, min=0.0, soft_max=1.0, step=0.01, subtype=\"FACTOR\")\n    mul_2 = FloatProperty(name=\"Marquise Profile Factor 2\", default=1.4, min=0.0, soft_max=2.0, step=0.01, subtype=\"FACTOR\")\n\n    bevel_corners = BoolProperty(name=\"Bevel Corners\")\n    bevel_corners_width = FloatProperty(name=\"Bevel Corners Width\", default=0.1, min=0.0, step=0.1, unit=\"LENGTH\")\n    bevel_corners_percent = FloatProperty(name=\"Bevel Corners Width (%)\", default=18.0, min=0.0, max=50.0, step=1, subtype=\"PERCENTAGE\")\n    bevel_corners_segments = IntProperty(name=\"Bevel Corners Segments\", default=1, min=1, soft_max=30, step=1)\n    bevel_corners_profile = FloatProperty(name=\"Bevel Corners Profile\", default=0.5, min=0.15, max=1.0, subtype=\"FACTOR\")\n\n    def execute(self, context):\n        bm = create_cutter(self)\n        asset.bm_to_scene(bm, name=\"Cutter\", color=self.color)\n\n        return {\"FINISHED\"}\n\n    def invoke(self, context, event):\n        if not context.active_object or not context.selected_objects:\n            self.report({\"ERROR\"}, \"At least one gem object must be selected\")\n            return {\"CANCELLED\"}\n\n        asset.get_gem(self, context)\n        prefs = context.user_preferences.addons[var.ADDON_ID].preferences\n        self.color = tuple(prefs.color_cutter)\n\n        if self.auto_presets:\n            init_presets(self)\n\n        return self.execute(context)\n"}
{"repo_path":"naksu/cfengine_beautifier cfbeautifier/test/__main__.py","content":"from __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport os\n\nthis_dir = os.path.realpath(os.path.dirname(os.path.realpath(__file__)))\nbeautifier_executable_path = os.path.join(this_dir, \"cf-beautifier\")\ntest_cf_dir = os.path.join(this_dir, \"test_cfs\")\n\nfrom .. import beautifier\nfrom ..color import Color\nfrom ..version_abstraction import string_from_file\nimport random\nfrom .. import structure\nfrom ..structure import Line\nfrom ..util import ParserError\nimport re\nimport shutil\nimport subprocess\nimport tempfile\nimport time\nimport unittest\n\ntemp_dir = os.path.join(tempfile.gettempdir(), \"cfbeautifier_tmp\")\n\ndef clear_temp_dir():\n  try:\n    shutil.rmtree(temp_dir)\n  except OSError:\n    pass\n  os.makedirs(temp_dir)\n\nclass TestStructureHelpers(unittest.TestCase):\n    def assertEqualWithDiff(self, actual, expected, message):\n        self.assertEqual(actual, expected,\n                         \"%s:\\nexpected: %s\\nactual    %s\" % (message, expected, actual))\n\n    def test_joined_lines(self):\n        test_cases = [(\"Joins empty array\", [[]], []),\n                      (\"Joins empty arrays\", [[], []], []),\n                      (\"Joins one arg\", [[Line(\"string\", 1)]], [Line(\"string\", 1)]),\n                      (\"Joins empty array with content\",\n                       [[], [Line(\"string\", 1)]], [Line(\"string\", 1)]),\n                      (\"Joins content with empty and more text\",\n                       [[Line(\"string\", 1)], [], [Line(\" more\", 0)]],\n                       [Line(\"string more\", 1)]),\n                      (\"Joins multiple lines and only uses first depth\",\n                       [[Line(\"string\", 1), Line(\"second line\", 2)],\n                        [Line(\" more\", 3), Line(\"third line\", 4), Line(\"fourth line\", 5)]],\n                       [Line(\"string\", 1),\n                        Line(\"second line more\", 2),\n                        Line(\"third line\", 4),\n                        Line(\"fourth line\", 5)]),\n                     ]\n        for (message, line_arrays, expected) in test_cases:\n          self.assertEqualWithDiff(structure.joined_lines(*line_arrays), expected, message)\n\n    def test_find_index(self):\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [1, 2, 3, 4]),\n                                 2, \"Finds in middle of list\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 1, [1, 2, 3, 4]),\n                                 0, \"Finds first item\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 4, [1, 2, 3, 4]),\n                                 3, \"Finds last item\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == \"no\", [1, 2, 3, 4]),\n                                 None, \"Return None if not found\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == \"no\", [1, 2, 3, 4],\n                                                      not_found = \"a\"),\n                                 \"a\", \"Usees not_found argument\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 2, [1, 2, 3, 4],\n                                                      not_found = \"a\"),\n                                 1, \"Not found does nothing when item found\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\", start_index = 1),\n                                 2, \"Respects start_index\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\", start_index = 0),\n                                 0, \"Respects start_index, no off by one after\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\", start_index = 2),\n                                 2, \"Respects start_index, no off by one before\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\",\n                                                      reverse = True),\n                                 2, \"Supports reverse argument\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\",\n                                                      start_index = 1,\n                                                      reverse = True),\n                                 0, \"Supports reverse argument with start index\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 3, [3, 2, 3, 4],\n                                                      not_found = \"a\",\n                                                      start_index = 2,\n                                                      reverse = True),\n                                 2, \"Supports reverse argument with start index, no off-by-one\")\n        self.assertEqualWithDiff(structure.find_index(lambda x: x == 1, [3, 2, 3, 4],\n                                                      not_found = \"a\",\n                                                      start_index = 2,\n                                                      reverse = True),\n                                 \"a\", \"Supports not finding in reverse\")\n\ndef cf_file_names():\n    return [os.path.join(test_cf_dir, name)\n            for name in os.listdir(test_cf_dir)\n            if re.match(r\"^((?!expected).)*$\", name) and name.endswith(\".cf\")]\n\ndef randomly_whitespaced(spec_string, line_endings):\n    \"return the string with random trailing whitespace at the end of each line\"\n    def random_chars(chars, count):\n        def random_char_or_none(ignored_arg):\n            x = random.randint(0, len(chars) - 1)\n            return chars[x]\n        return \"\".join(map(random_char_or_none, range(count)))\n    return (line_endings.join(map(lambda line: line + random_chars([\"\\t\", \" \", \"\"], 2),\n                              spec_string.split(line_endings)))\n              + random_chars([\"\\t\", \"\", line_endings, \"\"], 3))\n\nclass TestEndToEnd(unittest.TestCase):\n    def assertEqualLines(self, actual, expected, message):\n        def numbered_lines(document):\n            return [\"%3d: %s\" % (index, line) for index, line in enumerate(document.split(\"\\n\"))]\n        actual_lines = numbered_lines(actual)\n        expected_lines = numbered_lines(expected)\n        for actual_line, expected_line in zip(actual_lines, expected_lines):\n            self.assertEqual(actual_line, expected_line,\n                             \"+++ACTUAL\\n%s\\n\\n---EXPECTED\\n%s\\n\\n%s: Different lines\\n+'%s'\\n-'%s'\" %\n                                 (\"\\n\".join(actual_lines), \"\\n\".join(expected_lines),\n                                  message, actual_line, expected_line))\n\n    def _for_original_and_expected_in_each_cf_file(self, fn):\n        \"\"\"\n        Calls fn for each cf test file\n        fn must have signature (original, expected, cf_file_name) -\u003e None\n        \"\"\"\n        for cf_file_name in cf_file_names():\n            print(Color.red(cf_file_name))\n            expected_file_path = cf_file_name[0:-3] + \"_expected.cf\"\n            if not os.path.isfile(expected_file_path):\n              # There is no *_excepted.cf file. Assume cf_file_name is already formatted as expected\n              expected_file_path = cf_file_name\n            expected = string_from_file(expected_file_path)\n            original_cf_string = string_from_file(cf_file_name)\n            fn(original_cf_string, expected, cf_file_name)\n\n    def test_beautify(self):\n        seed = int(time.time())\n        print(\"Running test with random seed\", seed)\n        random.seed(seed)\n\n        def compare(original_cf_string, expected, cf_file_name):\n            options = beautifier.Options()\n            beautified = beautifier.beautified_string(original_cf_string,\n                                                      options = options)\n            # Beautification should match expected\n            self.assertEqualLines(beautified, expected, cf_file_name)\n            # Beautification should be convergent\n            self.assertEqualLines(beautifier.beautified_string(beautified, options = options),\n                                  beautified, cf_file_name + \" not convergent\")\n            # Should ignore white space\n            if not \"multiline_strings\" in cf_file_name:\n              # Multiline strings may not be appended white space without changing their meaning\n              self.assertEqualLines(beautifier.beautified_string(\n                                      randomly_whitespaced(original_cf_string,\n                                                            beautifier.line_endings(original_cf_string,\n                                                                                    None)),\n                                      options = options),\n                                    expected, cf_file_name + \" not convergent\")\n\n        self._for_original_and_expected_in_each_cf_file(compare)\n\n    def assertBeautifies(self, original, expected, options, message):\n        beautified = beautifier.beautified_string(original,\n                                                  options = options)\n        self.assertEqualLines(beautified, expected, message)\n\n    def test_error(self):\n        cf_string = \"\"\"bundle agent foo {\n  classes:\n    \"promise\" slist =\u003e =\u003e \"value\";\n}\n\"\"\"\n        try:\n          beautifier.beautified_string(cf_string)\n        except ParserError as error:\n          self.assertEqual(\"Syntax error, line 3, column 24: '=\u003e'\", str(error), \"Is human readable\")\n          self.assertEqual(3, error.line_number, \"Knows line number of the error\")\n          self.assertEqual(24, error.column, \"Knows column of the error\")\n          self.assertEqual(\"=\u003e\", error.fragment, \"Knows the text of the error\")\n          self.assertEqual(53, error.position, \"Knows the lexpos of the error\")\n        else:\n          self.fail(\"Did not raise except\")\n\n    def test_no_sort(self):\n        options = beautifier.Options()\n        options.sorts_promise_types_to_evaluation_order = False\n        original = \"\"\"bundle agent foo {\n                        classes:\n                          \"promise\";\n\n                        vars:\n                            \"promise2\";\n                      }\n                   \"\"\"\n        expected = \"\"\"bundle agent foo {\n  classes:\n      \"promise\";\n\n  vars:\n      \"promise2\";\n}\n\"\"\"\n        self.assertBeautifies(original, expected, options, \"Supports not sorting\")\n\n    def test_no_removal_of_empty(self):\n        options = beautifier.Options()\n        options.removes_empty_promise_types = False\n        original = \"\"\"bundle agent foo {\n                        vars:\n\n                       classes:\n                         \"promise\";\n                     }\n                   \"\"\"\n        expected = \"\"\"bundle agent foo {\n  vars:\n\n  classes:\n      \"promise\";\n}\n\"\"\"\n        self.assertBeautifies(original, expected, options, \"Supports non-removal of empty promises\")\n\n    def test_command_line_interface_with_stdin(self):\n        def compare(original_cf_string, expected, cf_file_name):\n            beautified, err = beautified_via_cli([], original_cf_string)\n            self.assertEqual(err, \"\")\n            self.assertEqualLines(beautified, expected, cf_file_name)\n\n        self._for_original_and_expected_in_each_cf_file(compare)\n\n    def test_command_line_interface_with_output_file(self):\n        clear_temp_dir()\n        def compare(original_cf_string, expected, cf_file_name):\n            output_path = os.path.join(temp_dir, \"tmp.cf\")\n            for stream in beautified_via_cli([\"--out\", output_path, cf_file_name],\n                                             original_cf_string):\n              self.assertEqual(stream, \"\")\n            self.assertEqualLines(string_from_file(output_path), expected, cf_file_name)\n\n        self._for_original_and_expected_in_each_cf_file(compare)\n\ndef beautified_via_cli(args, input):\n    process = subprocess.Popen([\"./cf-beautify\"] + args,\n                               stdin = subprocess.PIPE,\n                               stdout = subprocess.PIPE,\n                               stderr = subprocess.PIPE)\n    out, err = process.communicate(input.encode(\"utf-8\"))\n    out = out.decode('utf-8-sig')\n    err = err.decode('utf-8-sig')\n    return (out, err)\n\ndef main():\n    unittest.main()\n\nif __name__ == '__main__':\n  main()"}
{"repo_path":"apache/bloodhound trac/trac/wiki/tests/model.py","content":"# -*- coding: utf-8 -*-\n\nfrom __future__ import with_statement\n\nfrom datetime import datetime\nimport os.path\nimport shutil\nfrom StringIO import StringIO\nimport tempfile\nimport unittest\n\nfrom trac.attachment import Attachment\nfrom trac.core import *\nfrom trac.test import EnvironmentStub\nfrom trac.tests.resource import TestResourceChangeListener\nfrom trac.util.datefmt import utc, to_utimestamp\nfrom trac.wiki import WikiPage, IWikiChangeListener\n\n\nclass TestWikiChangeListener(Component):\n\n    implements(IWikiChangeListener)\n\n    def __init__(self):\n        self.added = []\n        self.changed = []\n        self.deleted = []\n        self.deleted_version = []\n        self.renamed = []\n\n    def wiki_page_added(self, page):\n        self.added.append(page)\n\n    def wiki_page_changed(self, page, version, t, comment, author, ipnr):\n        self.changed.append((page, version, t, comment, author, ipnr))\n\n    def wiki_page_deleted(self, page):\n        self.deleted.append(page)\n\n    def wiki_page_version_deleted(self, page):\n        self.deleted_version.append(page)\n\n    def wiki_page_renamed(self, page, old_name):\n        self.renamed.append((page, old_name))\n\n\nclass WikiPageTestCase(unittest.TestCase):\n\n    def setUp(self):\n        self.env = EnvironmentStub()\n        self.env.path = os.path.join(tempfile.gettempdir(), 'trac-tempenv')\n        os.mkdir(self.env.path)\n\n    def tearDown(self):\n        shutil.rmtree(self.env.path)\n        self.env.reset_db()\n\n    def test_new_page(self):\n        page = WikiPage(self.env)\n        self.assertEqual(False, page.exists)\n        self.assertEqual(None, page.name)\n        self.assertEqual(0, page.version)\n        self.assertEqual('', page.text)\n        self.assertEqual(0, page.readonly)\n        self.assertEqual('', page.author)\n        self.assertEqual('', page.comment)\n        self.assertEqual(None, page.time)\n\n    def test_existing_page(self):\n        t = datetime(2001, 1, 1, 1, 1, 1, 0, utc)\n        self.env.db_transaction(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            ('TestPage', 1, to_utimestamp(t), 'joe', '::1', 'Bla bla',\n             'Testing', 0))\n\n        page = WikiPage(self.env, 'TestPage')\n        self.assertEqual(True, page.exists)\n        self.assertEqual('TestPage', page.name)\n        self.assertEqual(1, page.version)\n        self.assertEqual(None, page.resource.version)   # FIXME: Intentional?\n        self.assertEqual('Bla bla', page.text)\n        self.assertEqual(0, page.readonly)\n        self.assertEqual('joe', page.author)\n        self.assertEqual('Testing', page.comment)\n        self.assertEqual(t, page.time)\n\n        history = list(page.get_history())\n        self.assertEqual(1, len(history))\n        self.assertEqual((1, t, 'joe', 'Testing', '::1'), history[0])\n\n        page = WikiPage(self.env, 'TestPage', 1)\n        self.assertEqual(1, page.resource.version)\n\n    def test_create_page(self):\n        page = WikiPage(self.env)\n        page.name = 'TestPage'\n        page.text = 'Bla bla'\n        t = datetime(2001, 1, 1, 1, 1, 1, 0, utc)\n        page.save('joe', 'Testing', '::1', t)\n\n        self.assertEqual(True, page.exists)\n        self.assertEqual(1, page.version)\n        self.assertEqual(1, page.resource.version)\n        self.assertEqual(0, page.readonly)\n        self.assertEqual('joe', page.author)\n        self.assertEqual('Testing', page.comment)\n        self.assertEqual(t, page.time)\n\n        self.assertEqual(\n            [(1, to_utimestamp(t), 'joe', '::1', 'Bla bla', 'Testing', 0)],\n            self.env.db_query(\"\"\"\n                SELECT version, time, author, ipnr, text, comment, readonly\n                FROM wiki WHERE name=%s\n                \"\"\", ('TestPage',)))\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual(page, listener.added[0])\n\n    def test_update_page(self):\n        t = datetime(2001, 1, 1, 1, 1, 1, 0, utc)\n        t2 = datetime(2002, 1, 1, 1, 1, 1, 0, utc)\n        self.env.db_transaction(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            ('TestPage', 1, to_utimestamp(t), 'joe', '::1', 'Bla bla',\n             'Testing', 0))\n\n        page = WikiPage(self.env, 'TestPage')\n        page.text = 'Bla'\n        page.save('kate', 'Changing', '192.168.0.101', t2)\n\n        self.assertEqual(2, page.version)\n        self.assertEqual(2, page.resource.version)\n        self.assertEqual(0, page.readonly)\n        self.assertEqual('kate', page.author)\n        self.assertEqual('Changing', page.comment)\n        self.assertEqual(t2, page.time)\n\n        with self.env.db_query as db:\n            rows = db(\"\"\"\n               SELECT version, time, author, ipnr, text, comment, readonly\n               FROM wiki WHERE name=%s\n               \"\"\", ('TestPage',))\n            self.assertEqual(2, len(rows))\n            self.assertEqual((1, to_utimestamp(t), 'joe', '::1', 'Bla bla',\n                              'Testing', 0), rows[0])\n            self.assertEqual((2, to_utimestamp(t2), 'kate', '192.168.0.101',\n                              'Bla', 'Changing', 0), rows[1])\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual((page, 2, t2, 'Changing', 'kate', '192.168.0.101'),\n                         listener.changed[0])\n\n        page = WikiPage(self.env, 'TestPage')\n        history = list(page.get_history())\n        self.assertEqual(2, len(history))\n        self.assertEqual((2, t2, 'kate', 'Changing', '192.168.0.101'),\n                         history[0])\n        self.assertEqual((1, t, 'joe', 'Testing', '::1'), history[1])\n\n    def test_delete_page(self):\n        self.env.db_transaction(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            ('TestPage', 1, 42, 'joe', '::1', 'Bla bla', 'Testing', 0))\n\n        page = WikiPage(self.env, 'TestPage')\n        page.delete()\n\n        self.assertEqual(False, page.exists)\n\n        self.assertEqual([], self.env.db_query(\"\"\"\n            SELECT version, time, author, ipnr, text, comment, readonly\n            FROM wiki WHERE name=%s\n            \"\"\", ('TestPage',)))\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual(page, listener.deleted[0])\n\n    def test_delete_page_version(self):\n        self.env.db_transaction.executemany(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            [('TestPage', 1, 42, 'joe', '::1', 'Bla bla', 'Testing', 0),\n             ('TestPage', 2, 43, 'kate', '192.168.0.11', 'Bla', 'Changing', 0)])\n\n        page = WikiPage(self.env, 'TestPage')\n        page.delete(version=2)\n\n        self.assertEqual(True, page.exists)\n        self.assertEqual(\n            [(1, 42, 'joe', '::1', 'Bla bla', 'Testing', 0)],\n            self.env.db_query(\"\"\"\n                SELECT version, time, author, ipnr, text, comment, readonly\n                FROM wiki WHERE name=%s\n                \"\"\", ('TestPage',)))\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual(page, listener.deleted_version[0])\n\n    def test_delete_page_last_version(self):\n        self.env.db_transaction(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            ('TestPage', 1, 42, 'joe', '::1', 'Bla bla', 'Testing', 0))\n\n        page = WikiPage(self.env, 'TestPage')\n        page.delete(version=1)\n\n        self.assertEqual(False, page.exists)\n\n        self.assertEqual([], self.env.db_query(\"\"\"\n            SELECT version, time, author, ipnr, text, comment, readonly\n            FROM wiki WHERE name=%s\n            \"\"\", ('TestPage',)))\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual(page, listener.deleted[0])\n\n    def test_rename_page(self):\n        data = (1, 42, 'joe', '::1', 'Bla bla', 'Testing', 0)\n        self.env.db_transaction(\n            \"INSERT INTO wiki VALUES(%s,%s,%s,%s,%s,%s,%s,%s)\",\n            ('TestPage',) + data)\n        attachment = Attachment(self.env, 'wiki', 'TestPage')\n        attachment.insert('foo.txt', StringIO(), 0, 1)\n\n        page = WikiPage(self.env, 'TestPage')\n        page.rename('PageRenamed')\n        self.assertEqual('PageRenamed', page.name)\n\n        self.assertEqual([data], self.env.db_query(\"\"\"\n            SELECT version, time, author, ipnr, text, comment, readonly\n            FROM wiki WHERE name=%s\n            \"\"\", ('PageRenamed',)))\n\n        attachments = Attachment.select(self.env, 'wiki', 'PageRenamed')\n        self.assertEqual('foo.txt', attachments.next().filename)\n        self.assertRaises(StopIteration, attachments.next)\n        Attachment.delete_all(self.env, 'wiki', 'PageRenamed')\n\n        old_page = WikiPage(self.env, 'TestPage')\n        self.assertEqual(False, old_page.exists)\n\n\n        self.assertEqual([], self.env.db_query(\"\"\"\n            SELECT version, time, author, ipnr, text, comment, readonly\n            FROM wiki WHERE name=%s\n            \"\"\", ('TestPage',)))\n\n        listener = TestWikiChangeListener(self.env)\n        self.assertEqual((page, 'TestPage'), listener.renamed[0])\n\n    def test_invalid_page_name(self):\n        invalid_names = ('../Page', 'Page/..', 'Page/////SubPage',\n                         'Page/./SubPage', '/PagePrefix', 'PageSuffix/')\n\n        for name in invalid_names:\n            page = WikiPage(self.env)\n            page.name = name\n            page.text = 'Bla bla'\n            t = datetime(2001, 1, 1, 1, 1, 1, 0, utc)\n            self.assertRaises(TracError, page.save, 'joe', 'Testing', '::1', t)\n\n        page = WikiPage(self.env)\n        page.name = 'TestPage'\n        page.text = 'Bla bla'\n        t = datetime(2001, 1, 1, 1, 1, 1, 0, utc)\n        page.save('joe', 'Testing', '::1', t)\n        for name in invalid_names:\n            page = WikiPage(self.env, 'TestPage')\n            self.assertRaises(TracError, page.rename, name)\n\nclass WikiResourceChangeListenerTestCase(unittest.TestCase):\n    INITIAL_NAME = \"Wiki page 1\"\n    INITIAL_TEXT = \"some text\"\n    INITIAL_AUTHOR = \"anAuthor\"\n    INITIAL_COMMENT = \"some comment\"\n    INITIAL_REMOTE_ADDRESS = \"::1\"\n\n    def setUp(self):\n        self.env = EnvironmentStub(default_data=True)\n        self.listener = TestResourceChangeListener(self.env)\n        self.listener.resource_type = WikiPage\n        self.listener.callback = self.listener_callback\n\n    def tearDown(self):\n        self.env.reset_db()\n\n    def test_change_listener_created(self):\n        self._create_wiki_page(self.INITIAL_NAME)\n        self.assertEqual('created', self.listener.action)\n        self.assertTrue(isinstance(self.listener.resource, WikiPage))\n        self.assertEqual(self.INITIAL_NAME, self.wiki_name)\n        self.assertEqual(self.INITIAL_TEXT, self.wiki_text)\n\n    def test_change_listener_text_changed(self):\n        wiki_page = self._create_wiki_page(self.INITIAL_NAME)\n        CHANGED_TEXT = \"some other text\"\n        wiki_page.text = CHANGED_TEXT\n        wiki_page.save(\"author1\", \"renamed_comment\", \"::2\")\n        self.assertEqual('changed', self.listener.action)\n        self.assertTrue(isinstance(self.listener.resource, WikiPage))\n        self.assertEqual(self.INITIAL_NAME, self.wiki_name)\n        self.assertEqual(CHANGED_TEXT, self.wiki_text)\n        self.assertEqual({\"text\":self.INITIAL_TEXT}, self.listener.old_values)\n\n    def test_change_listener_renamed(self):\n        wiki_page = self._create_wiki_page(self.INITIAL_NAME)\n        CHANGED_NAME = \"NewWikiName\"\n        wiki_page.rename(CHANGED_NAME)\n        self.assertEqual('changed', self.listener.action)\n        self.assertTrue(isinstance(self.listener.resource, WikiPage))\n        self.assertEqual(CHANGED_NAME, self.wiki_name)\n        self.assertEqual(self.INITIAL_TEXT, self.wiki_text)\n        self.assertEqual({\"name\":self.INITIAL_NAME}, self.listener.old_values)\n\n    def test_change_listener_deleted(self):\n        wiki_page = self._create_wiki_page(self.INITIAL_NAME)\n        wiki_page.delete()\n        self.assertEqual('deleted', self.listener.action)\n        self.assertTrue(isinstance(self.listener.resource, WikiPage))\n        self.assertEqual(self.INITIAL_NAME, self.wiki_name)\n\n    def _create_wiki_page(self, name=None):\n        name = name or self.INITIAL_NAME\n        wiki_page = WikiPage(self.env, name)\n        wiki_page.text = self.INITIAL_TEXT\n        wiki_page.save(\n            self.INITIAL_AUTHOR,\n            self.INITIAL_COMMENT,\n            self.INITIAL_REMOTE_ADDRESS)\n        return wiki_page\n\n    def listener_callback(self, action, resource, context, old_values = None):\n        self.wiki_name = resource.name\n        self.wiki_text = resource.text\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(unittest.makeSuite(WikiPageTestCase, 'test'))\n    suite.addTest(unittest.makeSuite(\n        WikiResourceChangeListenerTestCase, 'test'))\n    return suite\n\nif __name__ == '__main__':\n    unittest.main(defaultTest='suite')\n"}
{"repo_path":"alfa-addon/addon plugin.video.alfa/servers/decrypters/adfly.py","content":"# -*- coding: utf-8 -*-\r\n\r\nfrom base64 import b64decode\r\n\r\nfrom core import scrapertools\r\nfrom platformcode import logger\r\n\r\n\r\ndef get_long_url(short_url):\r\n    logger.info(\"short_url = '%s'\" % short_url)\r\n\r\n    data = scrapertools.downloadpage(short_url)\r\n    ysmm = scrapertools.find_single_match(data, \"var ysmm = '([^']+)';\")\r\n    b64 = \"\"\r\n    for i in reversed(range(len(ysmm))):\r\n        if i % 2:\r\n            b64 = b64 + ysmm[i]\r\n        else:\r\n            b64 = ysmm[i] + b64\r\n\r\n    decoded_uri = b64decode(b64)[2:]\r\n\r\n    if \"adf.ly/redirecting\" in decoded_uri:\r\n        data = scrapertools.downloadpage(decoded_uri)\r\n        decoded_uri = scrapertools.find_single_match(data, \"window.location = '([^']+)'\")\r\n\r\n    return decoded_uri\r\n"}
{"repo_path":"naparuba/opsbro test/test_docker.py","content":"#!/usr/bin/env python\n# Copyright (C) 2014:\n#    Gabes Jean, naparuba@gmail.com\n\nimport copy\nimport time\nimport threading\nfrom pprint import pprint\nfrom opsbro_test import *\n\nfrom opsbro.dockermanager import dockermgr\n\n\nclass TestDocker(OpsBroTest):\n    def setUp(self):\n        dockermgr.connect()\n        dockermgr.load_containers()\n    \n    \n    def test_docker(self):\n        if dockermgr.con is None:\n            return\n        \n        dockermgr.compute_stats()\n        time.sleep(1)\n        dockermgr.compute_stats()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}
{"repo_path":"LouisPlisso/pytomo pytomo/dns/rdtypes/mxbase.py","content":"# Copyright (C) 2003-2007, 2009, 2010 Nominum, Inc.\n#\n# Permission to use, copy, modify, and distribute this software and its\n# documentation for any purpose with or without fee is hereby granted,\n# provided that the above copyright notice and this permission notice\n# appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND NOMINUM DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\"\"\"MX-like base classes.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport cStringIO\nimport struct\n\nfrom .. import exception as dns_exception\nfrom .. import rdata as dns_rdata\nfrom .. import name as dns_name\n\nclass MXBase(dns_rdata.Rdata):\n    \"\"\"Base class for rdata that is like an MX record.\n\n    @ivar preference: the preference value\n    @type preference: int\n    @ivar exchange: the exchange name\n    @type exchange: dns_name.Name object\"\"\"\n\n    __slots__ = ['preference', 'exchange']\n\n    def __init__(self, rdclass, rdtype, preference, exchange):\n        super(MXBase, self).__init__(rdclass, rdtype)\n        self.preference = preference\n        self.exchange = exchange\n\n    def to_text(self, origin=None, relativize=True, **kw):\n        exchange = self.exchange.choose_relativity(origin, relativize)\n        return '%d %s' % (self.preference, exchange)\n\n    def from_text(cls, rdclass, rdtype, tok, origin = None, relativize = True):\n        preference = tok.get_uint16()\n        exchange = tok.get_name()\n        exchange = exchange.choose_relativity(origin, relativize)\n        tok.get_eol()\n        return cls(rdclass, rdtype, preference, exchange)\n\n    from_text = classmethod(from_text)\n\n    def to_wire(self, file, compress = None, origin = None):\n        pref = struct.pack(\"!H\", self.preference)\n        file.write(pref)\n        self.exchange.to_wire(file, compress, origin)\n\n    def to_digestable(self, origin = None):\n        return struct.pack(\"!H\", self.preference) + \\\n            self.exchange.to_digestable(origin)\n\n    def from_wire(cls, rdclass, rdtype, wire, current, rdlen, origin = None):\n        (preference, ) = struct.unpack('!H', wire[current : current + 2])\n        current += 2\n        rdlen -= 2\n        (exchange, cused) = dns_name.from_wire(wire[: current + rdlen],\n                                               current)\n        if cused != rdlen:\n            raise dns_exception.FormError\n        if not origin is None:\n            exchange = exchange.relativize(origin)\n        return cls(rdclass, rdtype, preference, exchange)\n\n    from_wire = classmethod(from_wire)\n\n    def choose_relativity(self, origin = None, relativize = True):\n        self.exchange = self.exchange.choose_relativity(origin, relativize)\n\n    def _cmp(self, other):\n        sp = struct.pack(\"!H\", self.preference)\n        op = struct.pack(\"!H\", other.preference)\n        v = cmp(sp, op)\n        if v == 0:\n            v = cmp(self.exchange, other.exchange)\n        return v\n\nclass UncompressedMX(MXBase):\n    \"\"\"Base class for rdata that is like an MX record, but whose name\n    is not compressed when converted to DNS wire format, and whose\n    digestable form is not downcased.\"\"\"\n\n    def to_wire(self, file, compress = None, origin = None):\n        super(UncompressedMX, self).to_wire(file, None, origin)\n\n    def to_digestable(self, origin = None):\n        f = cStringIO.StringIO()\n        self.to_wire(f, None, origin)\n        return f.getvalue()\n\nclass UncompressedDowncasingMX(MXBase):\n    \"\"\"Base class for rdata that is like an MX record, but whose name\n    is not compressed when convert to DNS wire format.\"\"\"\n\n    def to_wire(self, file, compress = None, origin = None):\n        super(UncompressedDowncasingMX, self).to_wire(file, None, origin)\n"}
{"repo_path":"dnanexus/rseqc rseqc/lib/bx/intervals/operations/complement.py","content":"\"\"\"\nComplement a set of intervals.\n\"\"\"\n\nimport psyco_full\n\nimport traceback\nimport fileinput\nfrom warnings import warn\n\nfrom bx.intervals.io import *\nfrom bx.intervals.operations import *\nfrom bx.bitset import MAX\n\ndef complement( reader, lens ):\n    # Handle any ValueError, IndexError and OverflowError exceptions that may be thrown when\n    # the bitsets are being created by skipping the problem lines\n    complement_reader = BitsetSafeReaderWrapper( reader, lens=lens )\n    bitsets = complement_reader.binned_bitsets( upstream_pad=0, downstream_pad=0, lens=lens )\n    # NOT them all\n    for key, value in bitsets.items():\n        value.invert()\n    # Read remaining intervals and subtract\n    for chrom in bitsets:\n        bitset = bitsets[chrom]\n        out_intervals = bits_set_in_range( bitset, 0, lens.get( chrom, MAX ) )\n        try:\n            # Write the intervals\n            for start, end in out_intervals:\n                fields = [\".\"  for x in range(max(complement_reader.chrom_col, complement_reader.start_col, complement_reader.end_col)+1)]\n                # default the column to a + if it exists\n                if complement_reader.strand_col \u003c len( fields ) and complement_reader.strand_col \u003e= 0:\n                    fields[complement_reader.strand_col] = \"+\"\n                fields[complement_reader.chrom_col] = chrom\n                fields[complement_reader.start_col] = start\n                fields[complement_reader.end_col] = end\n                new_interval = GenomicInterval(complement_reader, fields, complement_reader.chrom_col, complement_reader.start_col, complement_reader.end_col, complement_reader.strand_col, \"+\")\n                yield new_interval\n        except IndexError, e:\n            complement_reader.skipped += 1\n            # no reason to stuff an entire bad file into memmory\n            if complement_reader.skipped \u003c 10:\n                complement_reader.skipped_lines.append( ( complement_reader.linenum, complement_reader.current_line, str( e ) ) )\n            continue\n\n\n# def main():\n#     # test it all out\n#     f1 = fileinput.FileInput(\"dataset_7.dat\")\n#     g1 = GenomicIntervalReader(f1)\n#     for interval in complement(g1,{\"chr\":16000000}):\n#         print \"\\t\".join(interval)\n# \n# if __name__ == \"__main__\":\n#     main()\n"}
{"repo_path":"exelearning/iteexe exe/engine/templatestore.py","content":"# ===========================================================================\n# eXe \n# Copyright 2017, CeDeC\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n# ===========================================================================\n\"\"\"\nTemplateStore is responsible for managing the Packages which the eXe server\nhas loaded, (and loading and saving them?)\n\"\"\"\n\nfrom exe.engine.template      import Template\nfrom multiprocessing.sharedctypes import template\nimport logging\nlog = logging.getLogger(__name__)\n\n# ===========================================================================\nclass TemplateStore:\n    \"\"\"\n    TemplateStore is responsible for managing the Templates which the eXe server\n    has loaded, and loading and saving them\n    \"\"\"\n\n    def __init__(self, config):\n        self._config = config\n        self._templates = []\n        self._listeners = []\n\n    def getTemplates(self):\n        \"\"\"\n        (returns the list of templates)\n        \"\"\"\n        return self._templates\n    \n    def getTemplate(self, name):\n        \"\"\"\n        (returns a template given its name)\n        \"\"\"\n        for template in self._templates:\n            if template.name == name:\n                return template\n        return None\n\n    def delTemplate(self, template):\n        \"\"\"\n        (deletes a template)\n        \"\"\"\n        if (template in self._templates):\n            self._templates.remove(template)\n            \n            for listener in self._listeners:\n                listener.delTemplate(template)\n    \n    def addTemplate(self, template):\n        \"\"\"\n        (adds a template)\n        \"\"\"\n        if (template not in self._templates):\n            self._templates.append(template)\n            \n            for listener in self._listeners:\n                listener.addTemplate(template) \n            return True\n        else:\n            return False \n    \n    \n    def register(self, listener):\n        \"\"\"\n        (registers a listener interested in being informed of the changes in TemplateStore)\n        \"\"\"\n        self._listeners.append(listener)\n\n\n    def load(self):\n        log.debug(\"loadTemplates from %s\" % self._config.templatesDir)\n        for templatePath in self._config.templatesDir.files():\n            # Only load .elt files\n            if templatePath.basename().splitext()[1] == '.elt':\n                template = Template(templatePath)\n                if template.isValid():\n                    self.addTemplate(template)\n\n# ===========================================================================\n"}
{"repo_path":"instagrambot/instapro test.py","content":"from instabot import User, api, Sender, Getter\nimport logging.config\nimport unittest\nfrom instabot.user.user_controller import UserController\n\n\nclass TestUser(unittest.TestCase):\n\n    def test_getter(self):\n        get = Getter()\n        print (\"USERS AVAILABLE: %d\" % get.controller.queue.qsize())\n        resp = list(get.user_followers(\"4456846295\"))\n        self.assertTrue(len(resp) \u003e 0)\n        resp = list(get.user_following(\"4456846295\", total=5))\n        self.assertEqual(len(resp), 5)\n        resp = list(get.user_feed(\"4456846295\", total=10))\n        self.assertEqual(len(resp), 10)\n\n        resp = get.user_info(\"4456846295\")\n        self.assertEqual(resp[\"pk\"], 4456846295)\n        resp = get.user_info(\"ohld\")\n        self.assertEqual(resp[\"pk\"], 352300017)\n\n        resp = list(get.liked_media(total=0))\n        self.assertEqual(len(resp), 0)\n\n    def test_sender(self):\n        send = Sender(\"instabotproject\")\n        self.assertTrue(send.can_follow(\"ohld\"))\n        self.assertFalse(send.follow_followers(\"ohld\", total=1))\n\ndef add_users():\n    pass\n\nif __name__ == '__main__':\n    logging.config.fileConfig('instabot/log.conf')\n    log = logging.getLogger('main')\n    # add_users()\n    unittest.main()\n"}
{"repo_path":"kuri65536/python-for-android python3-alpha/python-libs/gdata/tlslite/utils/Python_RSAKey.py","content":"\"\"\"Pure-Python RSA implementation.\"\"\"\n\nfrom .cryptomath import *\nfrom . import xmltools\nfrom .ASN1Parser import ASN1Parser\nfrom .RSAKey import *\n\nclass Python_RSAKey(RSAKey):\n    def __init__(self, n=0, e=0, d=0, p=0, q=0, dP=0, dQ=0, qInv=0):\n        if (n and not e) or (e and not n):\n            raise AssertionError()\n        self.n = n\n        self.e = e\n        self.d = d\n        self.p = p\n        self.q = q\n        self.dP = dP\n        self.dQ = dQ\n        self.qInv = qInv\n        self.blinder = 0\n        self.unblinder = 0\n\n    def hasPrivateKey(self):\n        return self.d != 0\n\n    def hash(self):\n        s = self.writeXMLPublicKey('\\t\\t')\n        return hashAndBase64(s.strip())\n\n    def _rawPrivateKeyOp(self, m):\n        #Create blinding values, on the first pass:\n        if not self.blinder:\n            self.unblinder = getRandomNumber(2, self.n)\n            self.blinder = powMod(invMod(self.unblinder, self.n), self.e,\n                                  self.n)\n\n        #Blind the input\n        m = (m * self.blinder) % self.n\n\n        #Perform the RSA operation\n        c = self._rawPrivateKeyOpHelper(m)\n\n        #Unblind the output\n        c = (c * self.unblinder) % self.n\n\n        #Update blinding values\n        self.blinder = (self.blinder * self.blinder) % self.n\n        self.unblinder = (self.unblinder * self.unblinder) % self.n\n\n        #Return the output\n        return c\n\n\n    def _rawPrivateKeyOpHelper(self, m):\n        #Non-CRT version\n        #c = powMod(m, self.d, self.n)\n\n        #CRT version  (~3x faster)\n        s1 = powMod(m, self.dP, self.p)\n        s2 = powMod(m, self.dQ, self.q)\n        h = ((s1 - s2) * self.qInv) % self.p\n        c = s2 + self.q * h\n        return c\n\n    def _rawPublicKeyOp(self, c):\n        m = powMod(c, self.e, self.n)\n        return m\n\n    def acceptsPassword(self): return False\n\n    def write(self, indent=''):\n        if self.d:\n            s = indent+'\u003cprivateKey xmlns=\"http://trevp.net/rsa\"\u003e\\n'\n        else:\n            s = indent+'\u003cpublicKey xmlns=\"http://trevp.net/rsa\"\u003e\\n'\n        s += indent+'\\t\u003cn\u003e%s\u003c/n\u003e\\n' % numberToBase64(self.n)\n        s += indent+'\\t\u003ce\u003e%s\u003c/e\u003e\\n' % numberToBase64(self.e)\n        if self.d:\n            s += indent+'\\t\u003cd\u003e%s\u003c/d\u003e\\n' % numberToBase64(self.d)\n            s += indent+'\\t\u003cp\u003e%s\u003c/p\u003e\\n' % numberToBase64(self.p)\n            s += indent+'\\t\u003cq\u003e%s\u003c/q\u003e\\n' % numberToBase64(self.q)\n            s += indent+'\\t\u003cdP\u003e%s\u003c/dP\u003e\\n' % numberToBase64(self.dP)\n            s += indent+'\\t\u003cdQ\u003e%s\u003c/dQ\u003e\\n' % numberToBase64(self.dQ)\n            s += indent+'\\t\u003cqInv\u003e%s\u003c/qInv\u003e\\n' % numberToBase64(self.qInv)\n            s += indent+'\u003c/privateKey\u003e'\n        else:\n            s += indent+'\u003c/publicKey\u003e'\n        #Only add \\n if part of a larger structure\n        if indent != '':\n            s += '\\n'\n        return s\n\n    def writeXMLPublicKey(self, indent=''):\n        return Python_RSAKey(self.n, self.e).write(indent)\n\n    def generate(bits):\n        key = Python_RSAKey()\n        p = getRandomPrime(bits/2, False)\n        q = getRandomPrime(bits/2, False)\n        t = lcm(p-1, q-1)\n        key.n = p * q\n        key.e = 3  #Needed to be long, for Java\n        key.d = invMod(key.e, t)\n        key.p = p\n        key.q = q\n        key.dP = key.d % (p-1)\n        key.dQ = key.d % (q-1)\n        key.qInv = invMod(q, p)\n        return key\n    generate = staticmethod(generate)\n\n    def parsePEM(s, passwordCallback=None):\n        \"\"\"Parse a string containing a \u003cprivateKey\u003e or \u003cpublicKey\u003e, or\n        PEM-encoded key.\"\"\"\n\n        start = s.find(\"-----BEGIN PRIVATE KEY-----\")\n        if start != -1:\n            end = s.find(\"-----END PRIVATE KEY-----\")\n            if end == -1:\n                raise SyntaxError(\"Missing PEM Postfix\")\n            s = s[start+len(\"-----BEGIN PRIVATE KEY -----\") : end]\n            bytes = base64ToBytes(s)\n            return Python_RSAKey._parsePKCS8(bytes)\n        else:\n            start = s.find(\"-----BEGIN RSA PRIVATE KEY-----\")\n            if start != -1:\n                end = s.find(\"-----END RSA PRIVATE KEY-----\")\n                if end == -1:\n                    raise SyntaxError(\"Missing PEM Postfix\")\n                s = s[start+len(\"-----BEGIN RSA PRIVATE KEY -----\") : end]\n                bytes = base64ToBytes(s)\n                return Python_RSAKey._parseSSLeay(bytes)\n        raise SyntaxError(\"Missing PEM Prefix\")\n    parsePEM = staticmethod(parsePEM)\n\n    def parseXML(s):\n        element = xmltools.parseAndStripWhitespace(s)\n        return Python_RSAKey._parseXML(element)\n    parseXML = staticmethod(parseXML)\n\n    def _parsePKCS8(bytes):\n        p = ASN1Parser(bytes)\n\n        version = p.getChild(0).value[0]\n        if version != 0:\n            raise SyntaxError(\"Unrecognized PKCS8 version\")\n\n        rsaOID = p.getChild(1).value\n        if list(rsaOID) != [6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0]:\n            raise SyntaxError(\"Unrecognized AlgorithmIdentifier\")\n\n        #Get the privateKey\n        privateKeyP = p.getChild(2)\n\n        #Adjust for OCTET STRING encapsulation\n        privateKeyP = ASN1Parser(privateKeyP.value)\n\n        return Python_RSAKey._parseASN1PrivateKey(privateKeyP)\n    _parsePKCS8 = staticmethod(_parsePKCS8)\n\n    def _parseSSLeay(bytes):\n        privateKeyP = ASN1Parser(bytes)\n        return Python_RSAKey._parseASN1PrivateKey(privateKeyP)\n    _parseSSLeay = staticmethod(_parseSSLeay)\n\n    def _parseASN1PrivateKey(privateKeyP):\n        version = privateKeyP.getChild(0).value[0]\n        if version != 0:\n            raise SyntaxError(\"Unrecognized RSAPrivateKey version\")\n        n = bytesToNumber(privateKeyP.getChild(1).value)\n        e = bytesToNumber(privateKeyP.getChild(2).value)\n        d = bytesToNumber(privateKeyP.getChild(3).value)\n        p = bytesToNumber(privateKeyP.getChild(4).value)\n        q = bytesToNumber(privateKeyP.getChild(5).value)\n        dP = bytesToNumber(privateKeyP.getChild(6).value)\n        dQ = bytesToNumber(privateKeyP.getChild(7).value)\n        qInv = bytesToNumber(privateKeyP.getChild(8).value)\n        return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv)\n    _parseASN1PrivateKey = staticmethod(_parseASN1PrivateKey)\n\n    def _parseXML(element):\n        try:\n            xmltools.checkName(element, \"privateKey\")\n        except SyntaxError:\n            xmltools.checkName(element, \"publicKey\")\n\n        #Parse attributes\n        xmltools.getReqAttribute(element, \"xmlns\", \"http://trevp.net/rsa\\Z\")\n        xmltools.checkNoMoreAttributes(element)\n\n        #Parse public values (\u003cn\u003e and \u003ce\u003e)\n        n = base64ToNumber(xmltools.getText(xmltools.getChild(element, 0, \"n\"), xmltools.base64RegEx))\n        e = base64ToNumber(xmltools.getText(xmltools.getChild(element, 1, \"e\"), xmltools.base64RegEx))\n        d = 0\n        p = 0\n        q = 0\n        dP = 0\n        dQ = 0\n        qInv = 0\n        #Parse private values, if present\n        if element.childNodes.length\u003e=3:\n            d = base64ToNumber(xmltools.getText(xmltools.getChild(element, 2, \"d\"), xmltools.base64RegEx))\n            p = base64ToNumber(xmltools.getText(xmltools.getChild(element, 3, \"p\"), xmltools.base64RegEx))\n            q = base64ToNumber(xmltools.getText(xmltools.getChild(element, 4, \"q\"), xmltools.base64RegEx))\n            dP = base64ToNumber(xmltools.getText(xmltools.getChild(element, 5, \"dP\"), xmltools.base64RegEx))\n            dQ = base64ToNumber(xmltools.getText(xmltools.getChild(element, 6, \"dQ\"), xmltools.base64RegEx))\n            qInv = base64ToNumber(xmltools.getText(xmltools.getLastChild(element, 7, \"qInv\"), xmltools.base64RegEx))\n        return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv)\n    _parseXML = staticmethod(_parseXML)\n"}
